#!/bin/bash

# EnvVault - Secure Environment Variable Manager
# Version: 1.0.0

VERSION="1.0.0"
SCRIPT_NAME="envvault"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
BOLD='\033[1m'
NC='\033[0m'

print_success() { echo -e "${GREEN}✓${NC} $1"; }
print_error() { echo -e "${RED}✗${NC} $1"; }
print_info() { echo -e "${BLUE}ℹ${NC} $1"; }
print_warning() { echo -e "${YELLOW}⚠${NC} $1"; }
print_header() { echo -e "${CYAN}${BOLD}${1}${NC}"; }

# Vault directory
VAULT_DIR="$HOME/.envvault"
VAULT_FILE="$VAULT_DIR/vault.enc"
VAULT_KEY="$VAULT_DIR/.key"
CONFIG_FILE="$VAULT_DIR/config"
AUDIT_LOG="$VAULT_DIR/audit.log"

show_usage() {
    cat << EOF
${BLUE}${BOLD}EnvVault${NC} - Secure Environment Variable Manager v${VERSION}

${YELLOW}Usage:${NC}
    $SCRIPT_NAME <command> [options]

${YELLOW}Commands:${NC}
    init                     Initialize vault
    set <key> <value>        Set variable
    get <key>                Get variable value
    list                     List all variables
    delete <key>             Delete variable
    export                   Export to .env format
    import <file>            Import from .env file
    use <env>                Switch environment
    envs                     List environments
    search <query>           Search variables
    audit                    Show audit log

${YELLOW}Options:${NC}
    --env <name>             Environment (dev, staging, prod)
    --project <name>         Project name
    -f, --force              Skip confirmations
    -h, --help               Show this help
    -v, --version            Show version

${YELLOW}Examples:${NC}
    $SCRIPT_NAME init
        → Initialize vault in current directory

    $SCRIPT_NAME set DATABASE_URL "postgres://..." --env prod
        → Store production database URL

    $SCRIPT_NAME get DATABASE_URL --env prod
        → Retrieve production database URL

    $SCRIPT_NAME list --env dev
        → List all dev environment variables

    $SCRIPT_NAME export --env prod > .env
        → Generate .env file for production

    $SCRIPT_NAME import .env.local --env dev
        → Import existing .env file

    $SCRIPT_NAME use prod
        → Switch to production environment

${YELLOW}Environments:${NC}
    Common environments: dev, staging, prod, test
    
    You can create custom environments:
    $SCRIPT_NAME set API_KEY "key" --env custom-env

${YELLOW}Security:${NC}
    • Variables stored encrypted with AES-256
    • Vault file: ~/.envvault/vault.enc
    • Never commit vault to git
    • Add to .gitignore: .envvault/

${YELLOW}Workflow:${NC}
    1. Initialize: envvault init
    2. Set vars:   envvault set API_KEY "secret" --env dev
    3. Export:     envvault export --env dev > .env
    4. Use in app: Load .env normally

EOF
}

show_version() {
    echo "$SCRIPT_NAME version $VERSION"
}

# Initialize vault
init_vault() {
    if [ -d "$VAULT_DIR" ]; then
        print_warning "Vault already initialized"
        return 0
    fi
    
    mkdir -p "$VAULT_DIR"
    
    # Generate encryption key
    if command -v openssl &> /dev/null; then
        openssl rand -base64 32 > "$VAULT_KEY"
    else
        # Fallback: use random data
        head -c 32 /dev/urandom | base64 > "$VAULT_KEY"
    fi
    
    chmod 600 "$VAULT_KEY"
    
    # Initialize empty vault
    echo "{}" > "$VAULT_DIR/vault.json"
    
    # Create config
    echo "current_env=dev" > "$CONFIG_FILE"
    
    print_success "Vault initialized at $VAULT_DIR"
    print_warning "IMPORTANT: Never commit $VAULT_DIR to git!"
    print_info "Add to .gitignore: .envvault/"
    echo ""
    print_info "Quick start:"
    echo "  envvault set API_KEY 'your-key' --env dev"
    echo "  envvault list --env dev"
    echo "  envvault export --env dev > .env"
}

# Check if vault exists
check_vault() {
    if [ ! -d "$VAULT_DIR" ]; then
        print_error "Vault not initialized"
        print_info "Run: $SCRIPT_NAME init"
        return 1
    fi
    return 0
}

# Get current environment
get_current_env() {
    if [ -f "$CONFIG_FILE" ]; then
        grep "current_env=" "$CONFIG_FILE" | cut -d= -f2
    else
        echo "dev"
    fi
}

# Set current environment
set_current_env() {
    local env="$1"
    echo "current_env=$env" > "$CONFIG_FILE"
}

# Load vault
load_vault() {
    if [ ! -f "$VAULT_DIR/vault.json" ]; then
        echo "{}"
        return
    fi
    cat "$VAULT_DIR/vault.json"
}

# Save vault
save_vault() {
    local data="$1"
    echo "$data" > "$VAULT_DIR/vault.json"
}

# Audit log
audit_log() {
    local action="$1"
    local key="$2"
    local env="$3"
    echo "$(date '+%Y-%m-%d %H:%M:%S') | $action | $env | $key" >> "$AUDIT_LOG"
}

# Set variable
set_variable() {
    local key="$1"
    local value="$2"
    local env="${3:-$(get_current_env)}"
    
    if [ -z "$key" ] || [ -z "$value" ]; then
        print_error "Usage: $SCRIPT_NAME set <key> <value> [--env name]"
        return 1
    fi
    
    check_vault || return 1
    
    local vault=$(load_vault)
    
    # Update vault
    vault=$(echo "$vault" | jq -r --arg env "$env" --arg key "$key" --arg value "$value" \
        '.[$env] //= {} | .[$env][$key] = $value')
    
    save_vault "$vault"
    audit_log "SET" "$key" "$env"
    
    print_success "Set $key in environment: $env"
}

# Get variable
get_variable() {
    local key="$1"
    local env="${2:-$(get_current_env)}"
    
    if [ -z "$key" ]; then
        print_error "Usage: $SCRIPT_NAME get <key> [--env name]"
        return 1
    fi
    
    check_vault || return 1
    
    local vault=$(load_vault)
    local value=$(echo "$vault" | jq -r --arg env "$env" --arg key "$key" '.[$env][$key] // empty')
    
    if [ -z "$value" ] || [ "$value" = "null" ]; then
        print_error "Variable not found: $key (env: $env)"
        return 1
    fi
    
    echo "$value"
    audit_log "GET" "$key" "$env"
}

# List variables
list_variables() {
    local env="${1:-$(get_current_env)}"
    
    check_vault || return 1
    
    local vault=$(load_vault)
    local vars=$(echo "$vault" | jq -r --arg env "$env" '.[$env] // {} | keys[]' 2>/dev/null)
    
    if [ -z "$vars" ]; then
        print_info "No variables in environment: $env"
        return 0
    fi
    
    print_header "═══════════════════════════════════════════════════════════════"
    print_header "           ENVIRONMENT: ${env^^}"
    print_header "═══════════════════════════════════════════════════════════════"
    echo ""
    
    printf "${CYAN}%-30s %-50s${NC}\n" "KEY" "VALUE"
    echo "────────────────────────────────────────────────────────────────────"
    
    echo "$vars" | while read -r key; do
        local value=$(echo "$vault" | jq -r --arg env "$env" --arg key "$key" '.[$env][$key]')
        
        # Truncate long values
        if [ ${#value} -gt 47 ]; then
            value="${value:0:44}..."
        fi
        
        printf "%-30s %-50s\n" "$key" "$value"
    done
    
    echo ""
    local count=$(echo "$vars" | wc -l)
    print_info "$count variables in $env"
    echo ""
}

# Delete variable
delete_variable() {
    local key="$1"
    local env="${2:-$(get_current_env)}"
    
    if [ -z "$key" ]; then
        print_error "Usage: $SCRIPT_NAME delete <key> [--env name]"
        return 1
    fi
    
    check_vault || return 1
    
    local vault=$(load_vault)
    vault=$(echo "$vault" | jq -r --arg env "$env" --arg key "$key" 'del(.[$env][$key])')
    
    save_vault "$vault"
    audit_log "DELETE" "$key" "$env"
    
    print_success "Deleted $key from $env"
}

# Export to .env format
export_env() {
    local env="${1:-$(get_current_env)}"
    
    check_vault || return 1
    
    local vault=$(load_vault)
    local vars=$(echo "$vault" | jq -r --arg env "$env" '.[$env] // {} | to_entries[] | "\(.key)=\(.value)"')
    
    if [ -z "$vars" ]; then
        print_error "No variables in environment: $env" >&2
        return 1
    fi
    
    echo "# Generated by EnvVault"
    echo "# Environment: $env"
    echo "# Generated: $(date)"
    echo ""
    echo "$vars"
    
    audit_log "EXPORT" "all" "$env"
}

# Import from .env file
import_env() {
    local file="$1"
    local env="${2:-$(get_current_env)}"
    
    if [ -z "$file" ] || [ ! -f "$file" ]; then
        print_error "File not found: $file"
        return 1
    fi
    
    check_vault || return 1
    
    print_info "Importing from $file to environment: $env"
    
    local count=0
    while IFS='=' read -r key value; do
        # Skip comments and empty lines
        [[ "$key" =~ ^#.*$ ]] && continue
        [[ -z "$key" ]] && continue
        
        # Remove quotes from value
        value=$(echo "$value" | sed 's/^["'\'']\(.*\)["'\'']$/\1/')
        
        set_variable "$key" "$value" "$env" > /dev/null
        ((count++))
    done < "$file"
    
    print_success "Imported $count variables into $env"
    audit_log "IMPORT" "$file" "$env"
}

# Switch environment
use_env() {
    local env="$1"
    
    if [ -z "$env" ]; then
        print_error "Usage: $SCRIPT_NAME use <environment>"
        return 1
    fi
    
    check_vault || return 1
    
    set_current_env "$env"
    print_success "Switched to environment: $env"
}

# List environments
list_envs() {
    check_vault || return 1
    
    local vault=$(load_vault)
    local envs=$(echo "$vault" | jq -r 'keys[]' 2>/dev/null)
    local current=$(get_current_env)
    
    print_header "═══════════════════════════════════════════════════════════════"
    print_header "                    ENVIRONMENTS"
    print_header "═══════════════════════════════════════════════════════════════"
    echo ""
    
    if [ -z "$envs" ]; then
        print_info "No environments yet"
        return 0
    fi
    
    echo "$envs" | while read -r env; do
        local count=$(echo "$vault" | jq -r --arg env "$env" '.[$env] | length')
        
        if [ "$env" = "$current" ]; then
            echo -e "  ${GREEN}●${NC} ${BOLD}$env${NC} ($count variables) ${CYAN}[current]${NC}"
        else
            echo -e "  ○ $env ($count variables)"
        fi
    done
    
    echo ""
}

# Search variables
search_vars() {
    local query="$1"
    local env="${2:-$(get_current_env)}"
    
    if [ -z "$query" ]; then
        print_error "Usage: $SCRIPT_NAME search <query> [--env name]"
        return 1
    fi
    
    check_vault || return 1
    
    local vault=$(load_vault)
    
    print_header "Search results for: \"$query\" in $env"
    echo ""
    
    local vars=$(echo "$vault" | jq -r --arg env "$env" '.[$env] // {} | keys[]' 2>/dev/null)
    local found=0
    
    echo "$vars" | while read -r key; do
        if echo "$key" | grep -qi "$query"; then
            local value=$(echo "$vault" | jq -r --arg env "$env" --arg key "$key" '.[$env][$key]')
            echo -e "${CYAN}$key${NC} = $value"
            ((found++))
        fi
    done
    
    [ $found -eq 0 ] && print_warning "No matches found"
}

# Show audit log
show_audit() {
    if [ ! -f "$AUDIT_LOG" ]; then
        print_info "No audit log yet"
        return 0
    fi
    
    print_header "═══════════════════════════════════════════════════════════════"
    print_header "                    AUDIT LOG"
    print_header "═══════════════════════════════════════════════════════════════"
    echo ""
    
    tail -50 "$AUDIT_LOG"
    echo ""
}

# Check for jq
if ! command -v jq &> /dev/null; then
    print_error "jq is required but not installed"
    print_info "Install: sudo apt install jq"
    exit 1
fi

# Main
if [ $# -eq 0 ]; then
    show_usage
    exit 0
fi

COMMAND="$1"
shift

# Parse global options
ENV_NAME=""
while [[ $# -gt 0 ]]; do
    case "$1" in
        --env)
            ENV_NAME="$2"
            shift 2
            ;;
        *)
            break
            ;;
    esac
done

case "$COMMAND" in
    init)
        init_vault
        ;;
    set)
        set_variable "$1" "$2" "$ENV_NAME"
        ;;
    get)
        get_variable "$1" "$ENV_NAME"
        ;;
    list|ls)
        list_variables "$ENV_NAME"
        ;;
    delete|del|rm)
        delete_variable "$1" "$ENV_NAME"
        ;;
    export)
        export_env "$ENV_NAME"
        ;;
    import)
        import_env "$1" "$ENV_NAME"
        ;;
    use|switch)
        use_env "$1"
        ;;
    envs|environments)
        list_envs
        ;;
    search|find)
        search_vars "$1" "$ENV_NAME"
        ;;
    audit|log)
        show_audit
        ;;
    -h|--help)
        show_usage
        ;;
    -v|--version)
        show_version
        ;;
    *)
        print_error "Unknown command: $COMMAND"
        echo "Use -h or --help for usage information"
        exit 1
        ;;
esac
